package com.maeasoftworks.normativecontrol.controllers

import com.maeasoftworks.normativecontrol.dtos.docs.*
import com.maeasoftworks.normativecontrol.dtos.docs.MethodType.*
import com.maeasoftworks.normativecontrol.dtos.enums.ErrorType
import com.maeasoftworks.normativecontrol.dtos.enums.State
import org.springframework.beans.factory.annotation.Value
import org.springframework.http.HttpStatus
import org.springframework.stereotype.Controller
import org.springframework.ui.Model
import org.springframework.web.bind.annotation.CrossOrigin
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestParam
import java.net.InetAddress
import javax.annotation.PostConstruct

@Controller
@CrossOrigin
@RequestMapping("docs")
class DocumentationController {
    private final val accessKey = Argument("accessKey", "String", "key generated by client")
    private final val documentId = Argument("documentId", "String", "document id")
    private final val notFound = Response(HttpStatus.NOT_FOUND, description = "document not found")
    private final val accessDenied = Response(HttpStatus.FORBIDDEN, description = "access key is invalid")
    private lateinit var address: String
    @Value("\${server.port}")
    private lateinit var host: String

    @PostConstruct
    fun init() {
        val loopbackAddress = InetAddress.getLoopbackAddress().hostAddress
        val localAddress = InetAddress.getLocalHost().hostAddress

        address = if (localAddress.startsWith("192.168")) {
            "$loopbackAddress:$host"
        } else {
            loopbackAddress
        }
    }

    val methods = arrayOf(
        MethodInfo("documents", "queue", POST, "Prepares slot in queue.", listOf(accessKey), null, listOf(Response(HttpStatus.OK, "JSON", "slot prepared", "{\"documentId\":\$ID}"))),
        MethodInfo("documents", "state", GET, "Returns current state of document.", listOf(documentId, accessKey), null, listOf(notFound, accessDenied, Response(HttpStatus.OK, "JSON", "JSON object with document state. Possible states: ${State.values().map { it.name }}"))),
        MethodInfo("documents", "upload", POST, "Uses to upload document to server. Restrictions: <ul><li><code>docx</code> format</li><li>20 MB</li></ul>",null, listOf(documentId, accessKey, Argument("file", "MultipartFile", ".docx file that will be processed")), listOf(notFound, accessDenied, Response(HttpStatus.BAD_REQUEST, description = "required arguments were empty"), Response(HttpStatus.UNPROCESSABLE_ENTITY, description = "cannot process this document"), Response(HttpStatus.OK, description = "file successfully processed"))),
        MethodInfo("documents", "file", GET, "Returns processed file as ByteArrayResource. File will only be returned if processing was successful.", listOf(documentId, accessKey), null, listOf(notFound, accessDenied, Response(HttpStatus.OK, "ByteArray", "file as array of bytes"))),
        MethodInfo("documents", "errors", GET, "Returns errors in file. Errors will only be returned if processing was successful.", listOf(documentId, accessKey), null, listOf(notFound, accessDenied, Response(HttpStatus.OK, "JSON", "array of Error objects", "{\"errors\": [\$ERRORS]}"))),
        MethodInfo("documents", "drop-database", GET, "Drops database (testing-only).", null, null, listOf(Response(HttpStatus.OK, description = "database is clear now")))
    )

    val objects = arrayOf(
        ObjectInfo("Error", "Represents error found in document.",
            listOf(
            PropertyInfo("chapterId", "Int", "pointer to chapter in document"),
            PropertyInfo("paragraphId", "Int", "pointer to paragraph in document"),
            PropertyInfo("runId", "Int", "pointer to run in paragraph with <code>paragraphId</code>"),
            PropertyInfo("errorType", "ErrorType?", "error type. Can be:<br><ul>${
                ErrorType.values().joinToString("") { "<li>${it};</li>" }
            }</ul> or null (although it shouldn't)")))
    )

    @GetMapping
    fun mainPage(@RequestParam("section") section: String?, model: Model): String {
        model.addAttribute("methods", methods)
        model.addAttribute("objects", objects)
        model.addAttribute("address", address)
        model.addAttribute("sandboxEnabled", false)
        if (section != null && '/' in section) {
            model.addAttribute("isMethod", true)
            model.addAttribute("current", methods.first { it.root + "/" + it.path == section })
        } else if (section in objects.map { it.name }) {
            model.addAttribute("isMethod", false)
            model.addAttribute("current", objects.first { it.name == section })
        }
        else {
            model.addAttribute("current", null)
        }
        return "main"
    }
}